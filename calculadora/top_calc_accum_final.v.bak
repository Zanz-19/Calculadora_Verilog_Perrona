module top_calc_accum_final (
    input  wire clk,
    input  wire reset,           // síncrono
    input  wire [1:0] op_sel_raw,   // DIP switches (asíncronos)
    input  wire [7:0] data_in_raw,  // DIP switches (asíncronos)
    input  wire calc_btn_raw,       // pulsador (asíncrono)

    output wire [6:0] disp0,
    output wire [6:0] disp1,
    output wire [6:0] disp2,
    output wire [6:0] disp3,
    output wire [6:0] disp4,
    output wire neg_flag,
    output wire error_flag,
    output wire [7:0] acc_out
);
    // --- wires ---
    wire [1:0] op_sel;
    wire [7:0] data_in;
    wire calc_pulse;

    // op decoder wires
    wire op_add, op_sub, op_mul2, op_div2;

    // ALU wires
    wire signed [7:0] addsub_res;
    wire addsub_ovf;
    wire signed [7:0] muldiv_res;
    wire muldiv_err;

    wire signed [7:0] sel_res;
    wire ovf_flag_from_mux;
    wire muldiv_err_from_mux;

    wire acc_write_en;
    wire signed [7:0] acc_q;

    wire [3:0] D4, D3, D2, D1, D0;
    wire sign_bit;

    // --- instantiate synchronizers ---
    synchronizer #(.WIDTH(2)) sync_op(.clk(clk), .async_in(op_sel_raw), .sync_out(op_sel));
    synchronizer #(.WIDTH(8)) sync_data(.clk(clk), .async_in(data_in_raw), .sync_out(data_in));

    // debounce
    debounce_button #(.CNT_WIDTH(20)) db(.clk(clk), .rst(reset), .btn_raw(calc_btn_raw), .btn_pulse(calc_pulse));

    // op decoder
    op_decoder dec_op(.op_sel(op_sel), .op_add(op_add), .op_sub(op_sub), .op_mul2(op_mul2), .op_div2(op_div2));

    // ALUs
    alu_add_sub u_addsub(.a(acc_q), .b(data_in), .op_add(op_add), .result(addsub_res), .ovf(addsub_ovf));
    alu_shift_mul2_div2 u_muldiv(.a(acc_q), .op_mul2(op_mul2), .result(muldiv_res), .err(muldiv_err));

    // result mux
    result_mux u_mux(.op_sel(op_sel),
                     .addsub_res(addsub_res),
                     .addsub_ovf(addsub_ovf),
                     .muldiv_res(muldiv_res),
                     .muldiv_err(muldiv_err),
                     .sel_res(sel_res),
                     .ovf_flag(ovf_flag_from_mux),
                     .muldiv_err_flag(muldiv_err_from_mux));

    // overflow controller
    overflow_controller u_ovf_ctrl(.clk(clk),
                                   .rst(reset),
                                   .calc_pulse(calc_pulse),
                                   .ovf_in(ovf_flag_from_mux),
                                   .muldiv_err_in(muldiv_err_from_mux),
                                   .accept_write(acc_write_en),
                                   .error_flag(error_flag));

    // accumulator (connected to sel_res)
    accumulator u_acc (.clk(clk), .rst(reset), .load_en(acc_write_en), .d_in(sel_res), .acc_out(acc_q));

    // outputs
    assign acc_out = acc_q;
    assign neg_flag = acc_q[7];

    // bin2decimal and displays
    bin2decimal_fixed u_bin2dec(.acc(acc_q),
                                .d4(D4), .d3(D3), .d2(D2), .d1(D1), .d0(D0),
                                .sign(sign_bit));

    // show sign via neg_flag (already assigned); we keep sign LED separate (neg_flag output)

    display_driver_top u_disp(.d4(D4), .d3(D3), .d2(D2), .d1(D1), .d0(D0),
                              .disp4(disp4), .disp3(disp3), .disp2(disp2), .disp1(disp1), .disp0(disp0));

    // connect local disp signals to outputs (names in module)
    assign disp0 = disp0; // these are placeholders to satisfy port names (tool-specific)
    // The above self-assigns are placeholders only; depending on your tool, remove them and map outputs directly.
endmodule